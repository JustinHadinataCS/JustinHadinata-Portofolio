This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
HeroPage.jsx
Space.jsx
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="HeroPage.jsx">
import Space from "./Space";

function HeroPage() {
  return (
    <div className="min-h-screen bg-white flex flex-col">
      <nav className="flex justify-center items-center w-full space-x-5 py-4">
        <a>Home</a>
        <a>Home</a>
        <a>Home</a>
        <a>Home</a>
        <button className="px-4 py-1 bg-black text-white rounded-md text-center leading-normal">
          Let's talk
        </button>
      </nav>
      <div className="flex-1 px-8 lg:px-16 pt-16 md:pt-24">
        <div className="max-w-7xl mx-auto w-full">
          <div className="flex">
            <div className="flex-1 flex items-center justify-center">
              <div className="text-center mt-10">
                <h1 className="text-8xl mb-2 font-bold">Hi, I'm Justin</h1>
                <h2 className="text-5xl font-semibold">A Software Engineer</h2>
              </div>
            </div>
            <div className="flex-1 flex items-center justify-center">
              <Space />
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

export default HeroPage;
</file>

<file path="Space.jsx">
import { useEffect, useRef, useState } from "react";
import * as THREE from "three";

export default function Space() {
  const canvasRef = useRef(null);
  const sceneRef = useRef(null);
  const rendererRef = useRef(null);
  const spheresRef = useRef([]);
  const animationIdRef = useRef(null);
  const raycasterRef = useRef(new THREE.Raycaster());
  const mouseRef = useRef(new THREE.Vector2());
  const cameraRef = useRef(null);
  const tooltipRef = useRef(null);

  const [hoveredSphere, setHoveredSphere] = useState(null);

  const skillData = {
    1: { name: "Frontend", skills: "React, TypeScript, Tailwind, Three.js" },
    2: { name: "Backend", skills: "Node.js, Python, PostgreSQL, Docker" },
    3: { name: "Database", skills: "PostgreSQL, MongoDB, Redis, SQL" },
    4: { name: "DevOps", skills: "AWS, Docker, CI/CD, Kubernetes" },
    5: { name: "Tools", skills: "Git, VS Code, Linux, Figma" },
    6: { name: "Soft Skills", skills: "Problem Solving, Team Lead, Agile" },
  };

  useEffect(() => {
    if (!canvasRef.current) return;

    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xffffff); // White background
    sceneRef.current = scene;

    // Camera setup
    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.set(0, 0, 10);
    camera.lookAt(0, 0, 0);
    cameraRef.current = camera;

    // Renderer setup
    const renderer = new THREE.WebGLRenderer({
      canvas: canvasRef.current,
      antialias: true,
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    rendererRef.current = renderer;

    // Lighting setup
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
    scene.add(ambientLight);
    const pointLight = new THREE.PointLight(0xffffff, 1.5, 100);
    pointLight.position.set(10, 10, 10);
    scene.add(pointLight);
    const rimLight1 = new THREE.PointLight(0x00ffff, 0.8, 50);
    rimLight1.position.set(-10, 5, 5);
    scene.add(rimLight1);
    const rimLight2 = new THREE.PointLight(0xff00ff, 0.6, 50);
    rimLight2.position.set(5, -10, 5);
    scene.add(rimLight2);

    // Sphere specifications
    const sphereSpecs = [
      {
        position: [0, 0, 0],
        radius: 2.0,
        color: 0x1e40af,
        orbitRadius: 0,
        speed: 0,
        angleOffset: 0,
      },
      {
        position: [2.5, 0, 0],
        radius: 0.5,
        color: 0xf97316,
        orbitRadius: 5.0,
        speed: (2 * Math.PI) / 20,
        angleOffset: 0,
      },
      {
        position: [3.5, 0, 0],
        radius: 0.5,
        color: 0x16a34a,
        orbitRadius: 5.0,
        speed: (2 * Math.PI) / 20,
        angleOffset: Math.PI / 3,
      },
      {
        position: [4.5, 0, 0],
        radius: 0.5,
        color: 0xdc2626,
        orbitRadius: 5.0,
        speed: (2 * Math.PI) / 20,
        angleOffset: (2 * Math.PI) / 3,
      },
      {
        position: [5.5, 0, 0],
        radius: 0.5,
        color: 0x9333ea,
        orbitRadius: 5.0,
        speed: (2 * Math.PI) / 20,
        angleOffset: Math.PI,
      },
      {
        position: [6.5, 0, 0],
        radius: 0.5,
        color: 0xeab308,
        orbitRadius: 5.0,
        speed: (2 * Math.PI) / 20,
        angleOffset: (4 * Math.PI) / 3,
      },
      {
        position: [7.5, 0, 0],
        radius: 0.5,
        color: 0x06b6d4,
        orbitRadius: 5.0,
        speed: (2 * Math.PI) / 20,
        angleOffset: (5 * Math.PI) / 3,
      },
    ];

    const spheres = [];

    sphereSpecs.forEach((spec) => {
      const sphereGeometry = new THREE.IcosahedronGeometry(spec.radius, 0);
      const wireframeGeometry = new THREE.WireframeGeometry(sphereGeometry);
      const material = new THREE.LineBasicMaterial({
        color: spec.color,
        transparent: true,
        opacity: 0.8,
        linewidth: 1,
      });

      const wireframeSphere = new THREE.LineSegments(
        wireframeGeometry,
        material
      );
      wireframeSphere.position.set(
        spec.position[0],
        spec.position[1],
        spec.position[2]
      );
      wireframeSphere.userData = {
        orbitRadius: spec.orbitRadius,
        speed: spec.speed,
        angleOffset: spec.angleOffset,
      };
      scene.add(wireframeSphere);
      spheres.push(wireframeSphere);
    });

    spheresRef.current = spheres;

    const handleMouseMove = (event) => {
      mouseRef.current.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouseRef.current.y = -(event.clientY / window.innerHeight) * 2 + 1;

      if (!cameraRef.current) return;
      raycasterRef.current.setFromCamera(mouseRef.current, cameraRef.current);

      const orbitingSpheres = spheresRef.current.slice(1);
      const intersects = raycasterRef.current.intersectObjects(orbitingSpheres);

      if (intersects.length > 0) {
        const intersectedSphere = intersects[0].object;
        const sphereIndex = spheresRef.current.indexOf(intersectedSphere);
        setHoveredSphere(sphereIndex);
      } else {
        setHoveredSphere(null);
      }
    };
    canvasRef.current.addEventListener("mousemove", handleMouseMove);

    const animate = () => {
      animationIdRef.current = requestAnimationFrame(animate);
      const time = performance.now() / 1000;

      spheresRef.current.forEach((sphere, index) => {
        if (index === 0) {
          // Central sphere pulsation
          const scale = 1.0 + 0.1 * Math.sin(time * 2);
          sphere.scale.setScalar(scale);
          sphere.material.opacity = 0.6 + 0.3 * Math.sin(time * 3);
        } else {
          // Orbiting spheres
          const { orbitRadius, speed, angleOffset } = sphere.userData;
          const orbitTime = time * speed + angleOffset;
          const x = orbitRadius * Math.cos(orbitTime);
          const z = orbitRadius * Math.sin(orbitTime);
          sphere.position.set(x, 0, z);

          const pulseOpacity = 0.6 + Math.sin(time * 3 + index) * 0.2;
          sphere.material.opacity = Math.max(0.3, pulseOpacity);
        }

        sphere.rotation.y += 0.01 + index * 0.002;
        sphere.rotation.x += 0.003;
      });

      // Update tooltip position
      if (
        hoveredSphere !== null &&
        tooltipRef.current &&
        cameraRef.current &&
        rendererRef.current
      ) {
        const sphere = spheresRef.current[hoveredSphere];
        const position = new THREE.Vector3();
        sphere.getWorldPosition(position);
        position.project(cameraRef.current);

        const width = rendererRef.current.domElement.clientWidth;
        const height = rendererRef.current.domElement.clientHeight;

        const x = (position.x * 0.5 + 0.5) * width;
        const y = (position.y * -0.5 + 0.5) * height;

        tooltipRef.current.style.left = `${x}px`;
        tooltipRef.current.style.top = `${y}px`;
        tooltipRef.current.style.opacity = "1";
      } else if (tooltipRef.current) {
        tooltipRef.current.style.opacity = "0";
      }

      if (rendererRef.current && sceneRef.current && cameraRef.current) {
        renderer.render(sceneRef.current, cameraRef.current);
      }
    };
    animate();

    const handleResize = () => {
      if (!cameraRef.current || !rendererRef.current) return;
      cameraRef.current.aspect = window.innerWidth / window.innerHeight;
      cameraRef.current.updateProjectionMatrix();
      rendererRef.current.setSize(window.innerWidth, window.innerHeight);
    };
    window.addEventListener("resize", handleResize);

    return () => {
      // Cleanup logic
      if (animationIdRef.current) cancelAnimationFrame(animationIdRef.current);
      window.removeEventListener("resize", handleResize);
      if (canvasRef.current) {
        canvasRef.current.removeEventListener("mousemove", handleMouseMove);
      }
      // Consider adding cleanup for THREE.js objects (geometries, materials) here
    };
  }, []);

  return (
    <div className="relative w-screen h-screen overflow-hidden ">
      <canvas ref={canvasRef} className="block" />

      {/* Tooltip */}
      <div
        ref={tooltipRef}
        className="absolute pointer-events-none bg-gray-900/90 backdrop-blur-sm border border-gray-700 text-white px-4 py-3 rounded-lg shadow-lg transition-opacity duration-200 z-10"
        style={{
          opacity: 0,
          transform: "translate(-50%, -120%)",
        }}
      >
        {hoveredSphere && skillData[hoveredSphere] && (
          <>
            <div className="font-semibold text-sm text-white">
              {skillData[hoveredSphere].name}
            </div>
            <div className="text-xs text-gray-200 mt-1">
              {skillData[hoveredSphere].skills}
            </div>
          </>
        )}
      </div>
    </div>
  );
}
</file>

</files>
